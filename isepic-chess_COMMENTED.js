/** Copyright (c) 2012 Ajax Isepic (ajax333221) Licensed MIT		__________________________________________________________________________	This is a fully commented version (edit: not that fully, I stopped at 50% for today, line #479) of 'isepic-chess.js'	Note: this version MIGHT be outdated (I will try my best to prevent this though)*//*	Important things you need to know:		1)pos is for _arrays_ (e.g [7,7])		2)bos is for _strings_ (e.g "h1")		3)there is a bosToPos() and a posToBos() function		4)I work more with pos than bos, only for cases like en passant I use bos		5)the board is a 8x8 array, the [0,0] is the top-left corner ("a8") and [1,7] is "h7"		6)only Globals start with Uppercase		7)vars start with "rtn_x" when they return; something in a function		8)x_holder are arrays that hold stuff, they are confusing but prevent me of creating unnecessary variables		================================================		Not-So-Important-Things that you probably don't want to know:		*main*		1)/ * comment * / means upcoming feature, improvement or fix		2)[7,0] is the bottom-left, [7,7] is the bottom-right		3)testCollision() bol2 is to prevent the capture of pieces (used with pawns moving forward, or king castling)		4)ActiveChecks contains N number of checks		5)when setting/writting default FEN or board, use null to prevent preFenValidation() validation		6)<td id=TARGET, class=SQUARE_COLOR,ui-dro,highlight> <div class=PIECE,dra,ui-dra>		7)'pos' = an array with [0-7,0-7], 'bos' = a string with "a-h"+"1-8"				*performance*		1)every loop that need a break/continue has one, also see if outer: label is needed		2)cache values to don't check them again		3)use array holders to separate multiple similar ternary operations				*file-size*		1)cache array items that get called too much to save the [index] part (when aplicable)		2)use reverse loops when possible example: for(i=2;i--;){//1...0		3)use ~var for "is different than -1?"				*readibility*		1)arrange variables in this order: <i,j,len><temps><other><holders><returns>		2)similar blocks are NOT separated by line-breaks, there is an empty line above (if,for,functions,labels,etc)		3)the iterations of loops are commented //0...7		4)use parenthesis even when optional myFunction(true,(i+1));		5)prefer "" over ''		6)functions: lookLikeThis, globals: LookLikeThis, locals: look_like_this		7)use only one 'var' per function, but use separately 'var' on globals (unless very related)				*correct usage*		1)don't use null when a boolean is expected		2)work with numbers when expected (e.g indexes, castling avility) and strings (e.g en passant)		3)never leave empty function parameters*///these are the global variables we are going to use//note: the values of 'AbcLabels', 'PiecesNames' and 'DefaultFen' are not going to changevar AbcLabels="abcdefgh";var PiecesNames="*pnbrqk";//used with indexOf() to determine the value (p:1)(n:2)(b:3)(r:4)(q:5)(k:6)var DefaultFen="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";var ChessBoard;//ARRAY, an array of 8x8, empty squares are 0, positive numbers 1 to 6 are white pieces, negative numbers -1 to -6 are black piecesvar Fen;//STRING, holds the current Fen positionvar ActiveColor;//BOOLEAN, used for color to move, the values are (false:white)(true:black)var ActiveChecks;//NUMBER, holds the number of checks of the _active_ colorvar WCastling,BCastling;//NUMBER, used for castling avility (0:no avility)(1:short)(2:long)(3:both)var EnPassantBos;//STRING, will be either an empty string ("":empty) or a target square ("a1":square)var HalfMove,FullMove;//NUMBER, holds the half and full clocksvar WKingPos,BKingPos;//ARRAY, it will hold an array Pos like this ([0-7,0-7])var FromBos;//STRING, it will hold a string Bos like this "e4"//this function is the first part of the Fen validation (the second is 'postFenValidation()')//it checks for simple things that don't require advanced things like king position, etcfunction preFenValidation(complete_fen){	//PARAM_1 (complete_fen): STRING, a Fen position containing all parts (board, color, castling, etc)		var i,j,len,temp,last_is_num,current_is_num,rexp,ranks,piece_char,num_pieces,fen_parts,fen_first,fen_first_len,num_files,keep_going,rtn_is_legal;		rtn_is_legal=false;		//checks if the string is not empty	if(complete_fen){		//a regexp that will make sure the Fen looks like a Fen (Note: without checking for half/full clocks)		if(/^([rnbqkpRNBQKP1-8]+\/){7}([rnbqkpRNBQKP1-8]+)\s[bw]\s(-|K?Q?k?q?)\s(-|[a-h][36])/.test(complete_fen)){						fen_parts=complete_fen.split(" ",4);//I am only interesed in 'board', 'color', `castling` and 'enpassant', so I limit the array to 4			fen_first=fen_parts[0];//the first part of the Fen 'board'						/*line not necessary v*/			if(fen_parts.length>3){//I wrote this line prior to the Regexp, it is useless now				fen_first_len=fen_first.length;								//I replace K and k and see if they were removed, it makes sure there is exactly 1 w_king and 1 b_king				if(((fen_first_len-fen_first.replace(/K/g,"").length)==1)&&((fen_first_len-fen_first.replace(/k/g,"").length)==1)){					ranks=fen_first.split("/");//creates an array like this ["rnbqkbnr", "pppp1ppp", "8", ...]										//we check if the first and last ranks are free of pawns					if(!/p/gi.test(ranks[0]+""+ranks[7])){						keep_going=true;												outer:						for(i=8;i--;){//7...0, we will loop for each rank							num_files=0;//we will use this to see if everything adds to 8							last_is_num=false;//looks for two consecutive numbers (which aren't allowed)														for(j=0,len=ranks[i].length;j<len;j++){//0<len, we loop on every character of that row								temp=(ranks[i].charAt(j)*1);//will be NaN for pieces or a number for numbers								current_is_num=!!temp;//converts 'temp' into true or false																//if they both are true, it means we encounter two consecutive numbers								if(last_is_num&&current_is_num){									keep_going=false;									break outer;								}																last_is_num=current_is_num;																num_files+=(temp||1);//we add the values to later see if they equal to 8							}														//if they don't equal to 8, something is wrong and we must exit							if(num_files!=8){								keep_going=false;								break;							}						}												if(keep_going){//if everything is ok, we keep going...														//we will loop two times, one for white and other for black							for(i=2;i--;){//1...0																//we create an array to hold the total number 								//of pieces in these indexes:								//[pawns, knights, bishops, rooks, queens] (Note: not king because we								//already know there is the correct number of kings)								num_pieces=new Array(5);																//when 'j' is 4 we count for queens, when 3 for rooks ... 0 for pawns								for(j=5;j--;){//4...0									piece_char=PiecesNames.charAt(j+1);																		//we alternate white and black using 'i' in our two-time loop we started earlier									if(i){piece_char=piece_char.toUpperCase();}																		//the difference after removing the piece will tell us how many of									//that piece there were, and we will store it in our array									rexp=new RegExp(piece_char,"g");									num_pieces[j]=fen_first_len-(fen_first.replace(rexp,"").length);								}																//(num_pieces[0]<9) makes sure we don't have more than 8 pawns								//the other part is much more confusing but it actually makes a lot of sense:								//we take the total number of current (knights, bishops, rooks and queens) and remove								//the amount that we started with (8 for pawns, 2 for the rest other than queen,								//and 1 for queen), the resulting number can be positive, negative or zero								//we don't really care when it is zero or negative, however when it is								//positive it means that we have more than we normally do, which necessarily means								//we got the exceeding by promoting pawns, so if we add up all of								//these promoted pieces, we know that there MUST be at least the same amount of missing pawns								//and well, '8-num_pieces[0]' gives us the amount of missing pawns								//which leavs us with something like "promoted_extras <= missing pawns"								if(!((num_pieces[0]<9)&&((Math.max(num_pieces[1]-2,0)+Math.max(num_pieces[2]-2,0)+Math.max(num_pieces[3]-2,0)+Math.max(num_pieces[4]-1,0))<=(8-num_pieces[0])))){									keep_going=false;									break;								}							}														if(keep_going){								rtn_is_legal=true;//if it passed all tests, we will return 'true'							}						}					}				}			}		}	}		return rtn_is_legal;}//this function is the second part of the Fen validation (the first is 'preFenValidation()')//it does advanced stuff like watch number of checks, pawn formation and castling avilityfunction postFenValidation(){	var i,j,k,temp,temp2,temp3,keep_going,enpass_pos,castling_availity,king_rank,enpass_rank,enpass_file,fen_first,num_pawns,missing_capturables,min_captured,min_captured_holder,castle_holder,rtn_is_legal;		rtn_is_legal=false;		if(WKingPos&&BKingPos){//we make sure these exist		if((getValue(WKingPos)==6)&&(getValue(BKingPos)==-6)){//we check to see if the king positions are correct			if(ActiveChecks<3){//it is impossible to be legally checked more than 2 times				toggleActiveColor();				//we count the checks for the NON-active color				//Note: we passed 'true' so it stops looking once it finds 1 check (we don't really want to count them, just see if they were in check or not)				keep_going=!countChecks(true);				toggleActiveColor();								if(keep_going){//if this is 'false', it means that the non-active color was in check										//Note: in case of an empty 'EnPassantBos', it doesn't mean it is illegal, the					//'keep_going' will remain true and we continue normally					if(EnPassantBos){						keep_going=false;						enpass_pos=bosToPos(EnPassantBos);//example, turns STRING "e3" to ARRAY [5,4]						enpass_rank=enpass_pos[0];						enpass_file=enpass_pos[1];												if(!getValue(enpass_pos)){//the enpass square MUST be empty														//temp holds the rank where the enpass should be equal to							//temp2 holds a value, we will use it as a reference for two things (to see							//if we need to move the rank up or down, and to see if there is a pawn							//of the _correct_ color infront of the enpass square)							if(ActiveColor){								temp=5;								temp2=1;							}else{								temp=2;								temp2=-1;							}														//the first part checks to see if the rank is correct, taking in consideration the active color							//the second part makes sure the square _behind_ the enpass square is empty							//the third part checks to see if the square _infront_ the enpass square is occupied by a pawn of the correct color							//Note: by (behind/infront) and (up/down) I mean from the players view, so if							//it is for blacks we would need to alternate them							if(enpass_rank==temp&&!getValue([enpass_rank+temp2,enpass_file])&&(getValue([enpass_rank+(-temp2),enpass_file])==temp2)){								keep_going=true;							}						}					}										if(keep_going){						fen_first=Fen.split(" ")[0];//this will get the first part of a Fen (the 'board' part)												for(i=2;i--;){//1...0, one loop for white, other for black														//this is the number of remaining pieces that can be captured (15 is the max)							missing_capturables=15-(fen_first.length-(fen_first.replace((i?/p|n|b|r|q/g:/P|N|B|R|Q/g),"").length));							min_captured=0;//we will later update this value														//we will loop for each _file_, making an approximated guess of how many pieces							//must be missing in order to explain the pawn formation when there is more than one pawn per file							for(j=8;j--;){//7...0																//the first array is when working with 'a' or 'h' files								//Note: it is impossible to have 6 pawns in a single 'a' or 'h' file (that								//is why I used a 99)								min_captured_holder=((j==7)||!j)?[1,3,6,10,99]:[1,2,4,6,9];								temp3="..";																for(k=8;k--;){//7...0									temp3+=(getValue([k,j])||"")+"..";//storing the vertical file in a string								}																num_pawns=temp3.match(i?/\.1\./g:/\.-1\./g);								num_pawns=(num_pawns?num_pawns.length:0);//counting the number of pawns in a single file																if(num_pawns>1){//we are only interessed when there is more than 1 pawn									//using the number of pawns, we can get an approximate of the pieces									//that were needed to make the pawn formation using the values of the array 'min_captured_holder'									//Example, if number of pawns is 2 (in any file), 2-2=0, so we take									//index 0 and will give us "1" (any array), the enemy must be									//missing 1 piece in order to have doubled pawns									//Example2, if number of pawns is 4, it depends if we are in 1 or 8,									//or 2-7 files, lets say we are inside the 2-7 files, we will									//use the [1,2,4,6,9] array, 4-2=2, we take index 2 of the array									//and we find that the enemy must be missing at least "4" pieces to have 4 pawns in a single file									min_captured+=min_captured_holder[num_pawns-2];								}							}														if(min_captured>missing_capturables){//false when the enemy is NOT missing the minimum amount of pieces needed to help the pawns move into a single file								keep_going=false;								break;							}						}												if(keep_going){														//we will check if the castling avility makes							//sense, for both sides (thats why the 2 times loop)							for(i=2;i--;){//1...0								castle_holder=i?[0,-6,-4,BCastling]:[7,6,4,WCastling];								king_rank=castle_holder[0];								castling_availity=castle_holder[3];																//Note: in case of 'castling_availity' being 0, it doesn't mean it is illegal, the								//'keep_going' will remain true and we continue normally								if(castling_availity){																		//we make sure there is a king (6 or -6) in the e1/e8									//Note: e1=[7,4] and e8=[0,4], king_rank is used to determine 0 or 7									if(getValue([king_rank,4])!=castle_holder[1]){										keep_going=false;																		//in case of _short_, we look for the rook to be in h1/h8									}else if((castling_availity==1||castling_availity==3)&&(getValue([king_rank,7])!=castle_holder[2])){										keep_going=false;																		//in case of _long_, we look for the rook to be in a1/a8									}else if((castling_availity>1)&&(getValue([king_rank,0])!=castle_holder[2])){										keep_going=false;									}								}																if(!keep_going){									break;								}							}														if(keep_going){								rtn_is_legal=true;//if it passed all tests, we will return 'true'							}						}					}				}			}		}	}		return rtn_is_legal;}//this function is used to fix spacing in stringsfunction fixSpacing(rtn_string){	//PARAM_1 (rtn_string): STRING, a string that might be missing proper spacing and need to be fixed		//replace #1)removes spaces at the begining	//replace #2)converts two or more spaces into a single one	//replace #3)removes spaces at the end	return rtn_string.replace(/^\s+/,"").replace(/\s+$/,"").replace(/\s\s+/g," ");	//Example: " hello   world " into "hello world"}//this function is used to count number of checks from the _active_ colorfunction countChecks(early_break){	//PARAM_1 (early_break): BOOLEAN, this boolean is used to early break from the loop as soon as a check is found	var i,j,rtn_num_checks;		rtn_num_checks=0;		//we are going to test for 16 directions, 8 as a queen and 8 as a knight	//the reason behind this is that you can only be attacked from these squares	//so we will use a function that goes into all these directions and	//see if we found an enemy capable of attacking back returned by 'rtn_is_attacked' from 'testCollision()'	outer:	for(i=2;i--;){//1...0, the 'i' is used to pass it to 'testCollision' as 'is_knight'		for(j=9;--j;){//8...1, the 'j' is used to pass it to 'testCollision' as 'piece_direction'						//Note: by using null as 'num_squares', it will automatically			//give 7 to queen-mode and 1 with knight-mode			if(testCollision((ActiveColor?BKingPos:WKingPos),j,null,!i,true,true,null)[1]){				rtn_num_checks++;								if(early_break){					break outer;				}			}		}	}		return rtn_num_checks;}//sets the king position of the color-to-move kingfunction setKingPos(new_pos){	//PARAM_1 (new_pos): ARRAY	//updates: (W/B)KingPos		if(ActiveColor){		BKingPos=new_pos;	}else{		WKingPos=new_pos;	}}//toggles the side to move (white to black, black to white)function toggleActiveColor(){	//updates: ActiveColor	ActiveColor=!ActiveColor;}//this function turns STRING "e3" to an ARRAY [5,4]function bosToPos(bos){	//PARAM_1 (bos): STRING		return [Math.abs((bos.charAt(1)*1)-8),AbcLabels.indexOf(bos.charAt(0))];}//this function turns an ARRAY [5,4] to a STRING "e3"function posToBos(pos){	//PARAM_1 (pos): ARRAY		return (AbcLabels.charAt(pos[1])+""+Math.abs(pos[0]-8));}//returns a value from the chess board in a given position, -6 to 6 (including 0 as empty squares)function getValue(pos){	//PARAM_1 (pos): ARRAY		return ChessBoard[pos[0]][pos[1]];}//updates chessboard giving a new value to a given positionfunction setValue(pos,new_val){	//PARAM_1 (pos): ARRAY	//PARAM_2 (new_val): NUMBER (-6 to 6, including 0)		ChessBoard[pos[0]][pos[1]]=new_val;}//this function is used to see if the castling avility needs an update after//something moved into a corner, or to see if a rook that just moved came from a corner//in either case, if the square was a corner, a new castling avility is returnedfunction cornerRookTest(rtn_castling_avility,corner_bos,promotion_rank){	//PARAM_1 (rtn_castling_avility): NUMBER (0 to 3)	//PARAM_2 (corner_bos): STRING	//PARAM_3 (promotion_rank): NUMBER (1 _or_ 8)		if(rtn_castling_avility){//a quick test to see if we actually be making any changes				if(corner_bos==("h"+promotion_rank)&&rtn_castling_avility!=2){//short			//we lost _short_ avility (1 or 3) to (0 or 2)			rtn_castling_avility--;		}else if(corner_bos==("a"+promotion_rank)&&rtn_castling_avility!=1){//long			//we lost _long_ avility (2 or 3) to (0 or 1)			rtn_castling_avility-=2;		}	}		return rtn_castling_avility;}//check if a pos is within the limits of the 8x8 boardfunction insideBoard(pos){	//PARAM_1 (pos): ARRAY		//true if it falls between 0-7 and 0-7	return ((pos[0]<8&&pos[0]>-1)&&(pos[1]<8&&pos[1]>-1));}//the responsable of writting the HTML board, along with the promotion box and fen display boxfunction writeBoard(complete_fen){	//PARAM_1 (complete_fen): STRING	//Note: for setting up a default position use the null shortcut to make preFenValidation() fail quickly		var i,j,square_color,html_board;		if(!$("#xchessboard").length){//only proceed if it doesn't already exist		html_board="<div id='xchessboard'><table cellpadding='0' cellspacing='0'><tbody>";		square_color=true;				for(i=0;i<8;i++){//0...7			html_board+="<tr>";						for(j=0;j<8;j++){//0...7				html_board+="<td class='"+(square_color?"w":"b")+"s' id='"+posToBos([i,j])+"'></td>";				square_color=!square_color;			}						square_color=!square_color;			html_board+="</tr>";		}				html_board+="</tbody></table><input id='xfen' type='text' /><textarea id='xpgn'></textarea>promote to:<select id='xpromote'><option selected='selected' value='5'>queen</option><option value='4'>rook</option><option value='3'>bishop</option><option value='2'>knight</option></select></div>";				$("body").append(html_board);	}		setFEN(complete_fen);//we call the setFEN() passing the Fen position}//this function will break the Fen into their parts and assing them into the correspondent Globals//it will also call the two validation functions ('preFenValidation()' and 'postFenValidation()')//upon failing validation, a position using the 'DefaultFen' will be generated immediatelyfunction setFEN(complete_fen){	//PARAM_1 (complete_fen): STRING	//Note: for setting up a default position use the null shortcut to make preFenValidation() fail quickly	//updates: ChessBoard, ActiveColor, (W/B)Castling, EnPassantBos, (Half/Full)Move		var i,j,len,temp,temp2,ranks,current_file,skip_files,piece_char,fen_parts;		ChessBoard=new Array(8);		for(i=8;i--;){//7...0		ChessBoard[i]=[0,0,0,0,0,0,0,0];//0 are empty squares	}		//the "" fallback prevents an error when trying to apply .replace() to some non-string values	complete_fen=fixSpacing(complete_fen||"");	//an array like this ["8/8/...", "w", "KQq", "-", "0", "1"] from the positively _validated_ FEN (or DefaultFen)	fen_parts=(preFenValidation(complete_fen)?complete_fen:DefaultFen).split(" ");	ranks=fen_parts[0].split("/");//an array like this ["rnbqkbnr", "pppp1ppp", "8", ...]		//because we already validated, we can garantee ranks.length is equal to 8	for(i=8;i--;){//7...0		current_file=0;				//we loop through every char of each rank		for(j=0,len=ranks[i].length;j<len;j++){//0<len			temp=ranks[i].charAt(j);			skip_files=(temp*1);//we might be multiplying a number or a piece char, we don't know						if(skip_files){//if it was a number, we will move that number of spaces to the right				current_file+=skip_files;			}else{//if it was a piece...								//we conver it to lowercase to be able to use indexOf on it,				//also we will later see if the transformation affected the Case to				//determine if if we have a white piece or a black piece				piece_char=temp.toLowerCase();								//we set the value into ChessBoard, we make the value negative in case of a black piece				setValue([i,current_file],(PiecesNames.indexOf(piece_char)*(temp==piece_char?-1:1)));				//we advance 1 square to the right				current_file++;			}		}	}		ActiveColor=(fen_parts[1]=="b");//(false:white)(true:black)		temp2=fen_parts[2];	WCastling=(~temp2.indexOf("K")?1:0)+(~temp2.indexOf("Q")?2:0);//(0:no avility)(1:short)(2:long)(3:both)	BCastling=(~temp2.indexOf("k")?1:0)+(~temp2.indexOf("q")?2:0);//...		EnPassantBos=fen_parts[3].replace("-","");//either empty "" or a target bos "e3"		HalfMove=(fen_parts[4]*1)||0;//if missing we default to 0	FullMove=(fen_parts[5]*1)||1;//if missing we default to 1		refreshBoard();//we call the resposable of updating the visual part		if(!postFenValidation()){//if it fails the second validation, we generate a board with 'DefaultFen'		setFEN(null);//using null is a trick to make it fail the first validation quickly	}}//this function updates the outdated HTML board using the recently modified ChessBoard array//it also updates the globals 'Fen', '(W/B)KingPos' and 'ActiveChecks'//and after this, it calls a function to create the draggablesfunction refreshBoard(){	//updates: Fen, (W/B)KingPos, ActiveChecks	var i,j,piece_char,current_pos,current_val,current_abs_val,current_square_elm,empty_squares,new_fen,castling_holder,multi_holder,mini_holder;		castling_holder=["","k","q","kq"];	//the DOM elements with 'dra' class will be converted in draggables	multi_holder=ActiveColor?[" dra","","b"]:[""," dra","w"];	new_fen="";	WKingPos=null;	BKingPos=null;		//we will be looping in all 64 squares, and we will accomplish 3 goals here:	//1)apply all the changes from the recently-edited ChessBoard to the outdated DOM board	//2)find the King positions and store them in 'WKingPos' and 'BKingPos'	//3)update the new FEN position and display it at "#xfen"	for(i=0;i<8;i++){//0...7				//used for the FEN consecutive empty squares		empty_squares=0;				for(j=0;j<8;j++){//0...7			current_pos=[i,j];						current_val=getValue(current_pos);			current_abs_val=Math.abs(current_val);			current_square_elm=$("#"+posToBos(current_pos));						if(current_val){//a piece was found								//the first array is when dealing with a black piece, the other for a white piece				mini_holder=(current_val<0)?["b",multi_holder[0],false]:["w",multi_holder[1],true];								//the consecutive empty squares chain is broken, we add the				//number before erasing the value				if(empty_squares){					new_fen+=""+empty_squares;					empty_squares=0;				}								//if a king is found (w or b), we store that position				if(current_abs_val==6){					if(mini_holder[2]){						WKingPos=current_pos;					}else{						BKingPos=current_pos;					}				}								piece_char=PiecesNames.charAt(current_abs_val);//we get the piece char								//some examples of classes are "wp dra" and "wp"				//the " dra" will be given only when it is the piece turn, we				//will later turn all '.dra' into draggables using 'createDraggables()'				current_square_elm.html("<div class='"+mini_holder[0]+piece_char+""+mini_holder[1]+"'></div>");								//we add the piece char to the FEN, making it uppercase when working with black pieces				new_fen+=""+(mini_holder[2]?piece_char.toUpperCase():piece_char);							}else{//no piece was found				current_square_elm.html("");//we empty the square				empty_squares++;//we increase the "consecutive-empty-squares" used for FEN			}		}				//there might be a unbroken chain at this point, in the case it ran out of columns		if(empty_squares){			new_fen+=""+empty_squares;		}				new_fen+="/";//we separate the ranks using slashes		//Note: we add one slash even after the last loop (e.g "7K/8/8/8/8/8/8/7k/")	}		//we update the Fen	//Note: the "new_fen.slice(0,-1)" is to remove the extra slash '/' we talked about	Fen=(new_fen.slice(0,-1)+" "+multi_holder[2]+" "+((castling_holder[WCastling].toUpperCase()+""+castling_holder[BCastling])||"-")+" "+(EnPassantBos||"-")+" "+HalfMove+" "+FullMove);		ActiveChecks=countChecks(false);//update the number of checks of the active color		createDraggables();//converts the objects with ".dra" class into draggables		$("#xfen").val(Fen);//displays the new Fen}//this function takes a point in the board ('initial_pos') and starts moving towards//a direction ('piece_direction') for certain number of steps ('num_squares')////it can be used to://1)know if an enemy piece is attacking you _from_ that direction ('rtn_is_attacked')//    example 1: if you _are_ moving _diagonally_ and find an _enemy_ rook = false//    example 2: if you _are_ moving _diagonally_ and find an _enemy_ pawn (facing in//               the _correct_ direction) _BUT_ the pawn is more than 1 square apart = false//    example 3: if you are _NOT_ moving _like a knight_ and find an _enemy_ queen = true//    example 4: if you _are_ moving _like a knight_ and find an _enemy_ knight = true////2)know the squares you can move _in that direction_, the result//  will be an array ('rtn_arr_pos') containing "empty squares + possible captured"//  Note: these moves are _NOT_ validated yet, so you can be unprotecting your king or something////3)know if you collide with a specific ('ally_val') _ally_ piece, this will be//  used to check if a PGN move need to be disambiguatedfunction testCollision(initial_pos,piece_direction,num_squares,is_knight,prevent_capture,request_is_attacked,ally_val){	//PARAM_1 (initial_pos): ARRAY, the starting position	//PARAM_2 (piece_direction): NUMBER (1 to 8)		//				 8__  __1		//	8 1 2       7   ||   2		//	 \|/         |__][__|		// 7--X--3       |--][--|		//	 /|\        6 __||__ 3		//	6 5 4        5      4		//  (normal)     (knights)		//	//PARAM_3 (num_squares): NUMBER (1 to 7)	//Note: use the null shortcut to default knights to 1 and others pieces to 7	//PARAM_4 (is_knight): BOOLEAN, this is used to see if we will be moving like a knight	//PARAM_4 (prevent_capture): BOOLEAN, used for pawns moving forward or when checking	//                           if the castling path is not obstructed	//PARAM_5 (request_is_attacked): BOOLEAN, to see if you are under attack or not from	//                               the _current_ direction	//PARAM_6 (ally_val): NUMBER (exlucding 0, -6 to 6), piece values must _NOT_ be absolute	var i,temp,current_rank,current_file,current_pos,current_val,current_abs_val,move_rank_by,move_file_by,movement_holder,rtn_arr_pos,rtn_is_attacked,rtn_ally_pos;		rtn_arr_pos=[];	rtn_is_attacked=false;	rtn_ally_pos=[];	num_squares=(is_knight?1:(num_squares||7));/*add math max 7*/		movement_holder=is_knight?[[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1]]:[[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]];		temp=movement_holder[piece_direction-1];	move_rank_by=temp[0];	move_file_by=temp[1];		current_rank=initial_pos[0];	current_file=initial_pos[1];		for(i=0;i<num_squares;i++){//0<num_squares		current_rank+=move_rank_by;		current_file+=move_file_by;		current_pos=[current_rank,current_file];				if(!insideBoard(current_pos)){//stop if we reached end of board			break;		}				current_val=getValue(current_pos);		current_abs_val=Math.abs(current_val);//this will save us writting both "x" and "-X"				if(current_val){//if we collided with a piece (might be enemy or ally at this point)						//this check return true only for _enemy_ pieces			if((ActiveColor&&current_val>0)||(!ActiveColor&&current_val<0)){												if(request_is_attacked){//test only when needed										if(is_knight){						//if moving like a knight, only a knight can be attacking you						//Note: I didn't merge this if with an '&&' because I want to						//      trap them here to prevent the exec of the other 'else ifs'						if(current_abs_val==2){//knight							rtn_is_attacked=true;						}											//at this point we know we are _NOT_ moving like a knight, and knowing this					//makes it obvious that any collition with a queen means we are under attack					}else if(current_abs_val==5){//queen						rtn_is_attacked=true;					}else if(current_abs_val==6){//king						//after a king collition, we can only be under attack if						//we are next to it						if(!i){							rtn_is_attacked=true;						}										//piece_direction%2 return true for "+" directions (2,4,6,8)					}else if(piece_direction%2){						if(current_abs_val==4){//rook							rtn_is_attacked=true;						}										//if we are here, by deduction we can know that we are moving in "x"					//and if we collide with a bishop, it is attacking us back					}else if(current_abs_val==3){//bishop						rtn_is_attacked=true;										//remember that we still are in "x" direction, we see if we are					//next to the piece because pawns only attack at a range of 1					}else if(!i&&current_abs_val==1){												//this translates to "is it different than -1?"						if(~current_val){//w_pawn							//we want to exclude pawns that are _not_ facing to our direction							if(piece_direction==4||piece_direction==6){								rtn_is_attacked=true;							}						}else{//b_pawn							//we want to exclude pawns that are _not_ facing to our direction							if(piece_direction==2||piece_direction==8){								rtn_is_attacked=true;							}						}					}				}								//we check if we want to prevent the capture				//Note: I am _not_ completely sure if it is possible to ever attempt to capture				//      a king under my restrictions, but testCollition() is _sometimes_ called				//      from weird non-legit positions, so better be ready for all scenarios				if(!prevent_capture&&current_abs_val!=6){					rtn_arr_pos.push(current_pos);				}							//most of the time 'ally_val' will be null, but when it is not			//we will see if we collided with that value			//Note: I used _absolute_ values, but it is perfectly safe because			//      we are dealing with _allies_ only (if not we wouldn't be here)			}else if(Math.abs(ally_val)==current_abs_val){				rtn_ally_pos=current_pos;			}						break;//we stop					}else{//empty square			rtn_arr_pos.push(current_pos);//we can move into empty square, obviously		}	}		return [rtn_arr_pos,rtn_is_attacked,rtn_ally_pos];}/*--------------------comments end here for now*/function legalMoves(piece_pos,piece_val){	var i,j,len,len2,temp,facing_rank,current_adjacent_file,piece_abs_val,backup_val,current_pos,diagonal_pawn_pos,current_val,enpass_pos,pre_validated_arr_pos,castling_availity,can_castle,castle_holder,loop_holder,pawn_holder,rtn_validated_arr_pos;		pre_validated_arr_pos=[];	rtn_validated_arr_pos=[];	piece_abs_val=Math.abs(piece_val);		if(piece_abs_val==6){//king		for(i=9;--i;){//8...1			if((temp=testCollision(piece_pos,i,1,false,false,false,null)[0]).length){pre_validated_arr_pos.push(temp);}		}				castle_holder=ActiveColor?[BCastling,8,0,BKingPos]:[WCastling,1,7,WKingPos];		castling_availity=castle_holder[0];				if(castling_availity&&!ActiveChecks&&posToBos(piece_pos)==("e"+castle_holder[1])){			for(i=2;i--;){//1...0				loop_holder=i?[2,7,3,4,2]:[1,3,2,7,6];								if(castling_availity==3||castling_availity==loop_holder[0]){					if(testCollision(piece_pos,loop_holder[1],loop_holder[2],false,true,false,null)[0].length==loop_holder[2]){						can_castle=true;												for(j=loop_holder[3]-2;j<loop_holder[3];j++){//5...6 or 2...3							setKingPos([castle_holder[2],j]);														if(countChecks(true)){								can_castle=false;								break;							}						}												if(can_castle){							pre_validated_arr_pos.push([[castle_holder[2],loop_holder[4]]]);						}					}				}			}						setKingPos(castle_holder[3]);		}	}else if(piece_abs_val==5){//queen		for(i=9;--i;){//8...1			if((temp=testCollision(piece_pos,i,null,false,false,false,null)[0]).length){pre_validated_arr_pos.push(temp);}		}	}else if(piece_abs_val==4){//rook		for(i=9;--i;){//7,5,3,1			if((temp=testCollision(piece_pos,--i,null,false,false,false,null)[0]).length){pre_validated_arr_pos.push(temp);}		}	}else if(piece_abs_val==3){//bishop		for(i=9;--i;){//8,6,4,2			if((temp=testCollision(piece_pos,i--,null,false,false,false,null)[0]).length){pre_validated_arr_pos.push(temp);}		}	}else if(piece_abs_val==2){//knight		for(i=9;--i;){//8...1			if((temp=testCollision(piece_pos,i,null,true,false,false,null)[0]).length){pre_validated_arr_pos.push(temp);}		}	}else{//pawn		pawn_holder=ActiveColor?[1,5,1,5]:[6,1,-1,2];				if((temp=testCollision(piece_pos,pawn_holder[1],((piece_pos[0]==pawn_holder[0])?2:1),false,true,false,null)[0]).length){pre_validated_arr_pos.push(temp);}				facing_rank=(piece_pos[0]+pawn_holder[2]);				for(i=2;i--;){//1...0			current_adjacent_file=piece_pos[1]+(i?1:-1);			diagonal_pawn_pos=[facing_rank,current_adjacent_file];						if(insideBoard(diagonal_pawn_pos)){				current_val=(getValue(diagonal_pawn_pos)*pawn_holder[2]);								if(current_val>0&&current_val!=6){					pre_validated_arr_pos.push([diagonal_pawn_pos]);				}else if(facing_rank==pawn_holder[3]&&EnPassantBos){					enpass_pos=bosToPos(EnPassantBos);										if(enpass_pos[0]==facing_rank&&enpass_pos[1]==current_adjacent_file){						pre_validated_arr_pos.push([diagonal_pawn_pos]);					}				}			}		}	}		for(i=0,len=pre_validated_arr_pos.length;i<len;i++){//0<len		for(j=0,len2=pre_validated_arr_pos[i].length;j<len2;j++){//0<len2			current_pos=pre_validated_arr_pos[i][j];			backup_val=getValue(current_pos);						setValue(piece_pos,0);			setValue(current_pos,piece_val);						if(piece_abs_val==6){				setKingPos(current_pos);			}						if(!countChecks(true)){				rtn_validated_arr_pos.push(current_pos);			}						setValue(piece_pos,piece_val);			setValue(current_pos,backup_val);						if(piece_abs_val==6){				setKingPos(piece_pos);			}		}	}		return rtn_validated_arr_pos;}function draggableStart(){	//updates: FromBos	var i,len,initial_pos,candidates;		FromBos=$(this).parent().attr("id");	initial_pos=bosToPos(FromBos);	candidates=legalMoves(initial_pos,getValue(initial_pos));		for(i=0,len=candidates.length;i<len;i++){//0<len		$("#"+posToBos(candidates[i])).droppable({			drop:function(ev,ui){				var destination_square_elm,capturable_piece_elm;								destination_square_elm=$(this);				capturable_piece_elm=$("#"+destination_square_elm.attr("id")+" div");								if(capturable_piece_elm.length){					capturable_piece_elm.remove();				}								ui.draggable.removeAttr("style").appendTo(destination_square_elm);			}		}).addClass("highlight");	}}function draggableStop(){	//updates: ChessBoard, (W/B)Castling, EnPassantBos, (Half/Full)Move	var pgn_string_num,pgn_move,pawn_moved,promoted_val,piece_moved,piece_moved_class,piece_val,from_pos,to_pos,destination_bos,destination_file_char,destination_rank_char,new_enpass_bos,new_active_castling_availity,new_nonactive_castling_availity,king_castled,multi_holder;		$("td.highlight").droppable("destroy").removeClass("highlight");		piece_moved=$(this);	piece_moved_class=(" "+piece_moved.attr("class")+" ");	destination_bos=piece_moved.parent().attr("id");		if(destination_bos!=FromBos){		pawn_moved=false;		promoted_val=null;		multi_holder=ActiveColor?["b",8,[0,3],[0,5],-4,[0,0],[0,7],[7,6,5,4],BCastling,"1",-1,WCastling,1]:["w",1,[7,3],[7,5],4,[7,0],[7,7],[2,3,4,5],WCastling,"8",1,BCastling,8];		new_enpass_bos="";		new_active_castling_availity=multi_holder[8];		new_nonactive_castling_availity=multi_holder[11];		piece_val=null;		king_castled=null;				from_pos=bosToPos(FromBos);		to_pos=bosToPos(destination_bos);				if(~piece_moved_class.indexOf(" "+multi_holder[0]+"p ")){//pawn			piece_val=1;			pawn_moved=true;			destination_file_char=destination_bos.charAt(0);			destination_rank_char=destination_bos.charAt(1);						if(FromBos.charAt(1)==multi_holder[7][0]&&destination_rank_char==multi_holder[7][2]){//new enpass				new_enpass_bos=(destination_file_char+""+multi_holder[7][1]);			}else if(destination_bos==EnPassantBos){//pawn x enpass				setValue(bosToPos(destination_file_char+""+multi_holder[7][3]),0);			}else if(destination_rank_char==multi_holder[9]){//promotion				promoted_val=($("#xpromote").val()*multi_holder[10]);			}		}else if(~piece_moved_class.indexOf(" "+multi_holder[0]+"n ")){//knight			piece_val=2;		}else if(~piece_moved_class.indexOf(" "+multi_holder[0]+"b ")){//bishop			piece_val=3;		}else if(~piece_moved_class.indexOf(" "+multi_holder[0]+"r ")){//rook			piece_val=4;			new_active_castling_availity=cornerRookTest(new_active_castling_availity,FromBos,multi_holder[1]);		}else if(~piece_moved_class.indexOf(" "+multi_holder[0]+"q ")){//queen			piece_val=5;		}else if(~piece_moved_class.indexOf(" "+multi_holder[0]+"k ")){//king			piece_val=6;			new_active_castling_availity=0;						if(FromBos==("e"+multi_holder[1])){				if(destination_bos==("g"+multi_holder[1])){//short					king_castled=1;					setValue(multi_holder[3],multi_holder[4]);					setValue(multi_holder[6],0);				}else if(destination_bos==("c"+multi_holder[1])){//long					king_castled=2;					setValue(multi_holder[2],multi_holder[4]);					setValue(multi_holder[5],0);				}			}		}				pgn_string_num=ActiveColor?"":(FullMove+".");/*if no moves and 'b', use 1...*//*otro activeCol? -.-*/		pgn_move=getMove(from_pos,to_pos,(piece_val*multi_holder[10]),promoted_val,king_castled);				/*cache getValue(to_pos) and pass it to getMove as a param?? mmm?*/				HalfMove++;		if(pawn_moved||getValue(to_pos)){			HalfMove=0;		}				new_nonactive_castling_availity=cornerRookTest(new_nonactive_castling_availity,destination_bos,multi_holder[12]);				if(ActiveColor){			FullMove++;			BCastling=new_active_castling_availity;			WCastling=new_nonactive_castling_availity;		}else{			WCastling=new_active_castling_availity;			BCastling=new_nonactive_castling_availity;		}				EnPassantBos=new_enpass_bos;				setValue(to_pos,(promoted_val||getValue(from_pos)));		setValue(from_pos,0);				toggleActiveColor();		refreshBoard();				$("#xpgn").val($("#xpgn").val()+""+pgn_string_num+pgn_move+(ActiveChecks?"+":"")+" ");/*# when checkmate*/	}}function createDraggables(){	$(".dra").draggable({		cursorAt:{top:21,left:21},		revert:"invalid",		revertDuration:0,		zIndex:100,		scroll:false,		start:draggableStart,		stop:draggableStop	});}function getMove(initial_pos,final_pos,piece_val,promotion_val,castling_val){	var i,len,temp,temp2,temp3,piece_abs_val,initial_bos,initial_file_char,initial_rank_char,destination_bos,destination_file_char,collition_bos,ambiguity,is_knight,rtn_new_move;		rtn_new_move="";	initial_bos=posToBos(initial_pos);	initial_file_char=initial_bos.charAt(0);	initial_rank_char=initial_bos.charAt(1);		destination_bos=posToBos(final_pos);	destination_file_char=destination_bos.charAt(0);		piece_abs_val=Math.abs(piece_val);		if(piece_abs_val==1){//pawn		if(initial_file_char!=destination_file_char){			rtn_new_move+=(initial_file_char+"x");		}				rtn_new_move+=destination_bos;				if(promotion_val){			rtn_new_move+=("="+PiecesNames.charAt(Math.abs(promotion_val)).toUpperCase());		}	}else if(castling_val){//castling king		rtn_new_move+=(castling_val==1?"O-O":"O-O-O");	}else{//knight, bishop, rook, queen, non-castling king		rtn_new_move+=PiecesNames.charAt(piece_abs_val).toUpperCase();				if(piece_abs_val!=6){			temp2=[];			is_knight=(piece_abs_val==2);						for(i=(piece_abs_val!=3?9:1);--i;){//7,5,3,1				if((temp=testCollision(final_pos,--i,null,is_knight,false,false,piece_val)[2]).length){temp2.push(temp);}			}						for(i=(piece_abs_val!=4?9:1);--i;){//8,6,4,2				if((temp=testCollision(final_pos,i--,null,is_knight,false,false,piece_val)[2]).length){temp2.push(temp);}			}						len=temp2.length;			if(len>1){				temp3="";								for(i=0;i<len;i++){//0<len					collition_bos=posToBos(temp2[i]);										if(collition_bos!=initial_bos){						if(~(legalMoves(temp2[i],piece_val).join("")).indexOf(final_pos.join())){							temp3+=collition_bos;						}					}				}								ambiguity=(!!(~temp3.indexOf(initial_file_char))*1)+(!!(~temp3.indexOf(initial_rank_char))*2);								if(!ambiguity||ambiguity==2){					rtn_new_move+=initial_file_char;				}else if(ambiguity==1){					rtn_new_move+=initial_rank_char;				}else{					rtn_new_move+=(initial_file_char+""+initial_rank_char);				}			}		}				if(getValue(final_pos)){			rtn_new_move+="x";		}				rtn_new_move+=destination_bos;	}		return rtn_new_move;}